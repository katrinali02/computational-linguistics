def del_cost():
    return 1

def ins_cost():
    return 1

def sub_cost(c1, c2):
    if c1 == c2: 
        return 0
    else:
        return 2

def min_edit_distance(source, target, do_print_chart=False):
    """
    Compare `source` and `target` strings and return their edit distance with
    Levenshtein costs, according to the algorithm given in SLP Ch. 2, Figure 2.17.

    Parameters
    ----------
    source : str
        The source string.
    target : str
        The target string.

    Returns
    -------
    int
        The edit distance between the two strings.
    """

    # >>> YOUR ANSWER HERE
    n = len(source)
    m = len(target)

    #dictionary & initialization
    d = {}
    d[0,0] = 0 #how to access keys of dictionary: [] + whatever the key is in the braket --> here it's the (0,0) coordinate; = means assigned value to the keys
    for i in range(1,n+1): #+1 bc we need to include the last thing (left out) in order to get to n
        d[i,0] = d[i-1,0]+del_cost()
    for j in range(1,m+1):
        d[0,j] = d[0,j-1]+ins_cost()

    #recurrence relation
    for i in range(1,n+1):
        for j in range(1,m+1):
            d[i,j]=min(d[i-1,j]+del_cost(),
                        d[i-1,j-1]+sub_cost(source[i-1],target[j-1]),
                        d[i,j-1]+ins_cost())

    #termination
    return d[n,m]

    # >>> END YOUR ANSWER
        
if __name__ == '__main__':
    import sys
    
    if len(sys.argv) == 3:
        w1 = sys.argv[1]
        w2 = sys.argv[2]
    else:
        w1 = 'intention'
        w2 = 'execution'
    print('edit distance between', repr(w1), 'and', repr(w2), 'is', min_edit_distance(w1, w2))


